# -*- coding: utf-8 -*-
"""perceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gACFxaF4I4FY71IEQqBdUtMXB4JxMGWZ
"""

import numpy as np
import pandas as pd
import random
import sys

print(sys.argv)

np.random.seed(10)
data = pd.read_csv(sys.argv[2])
data.sort_values(by=[data.columns[len(data.columns)-1]], ascending=True, inplace=True)
erm_normal = False

if sys.argv[4] == "erm":
    erm_normal = True


def getX_Y(data):
    X = data.values[:, :len(data.columns) - 1]
    y = data.values[:, len(data.columns) - 1:len(data.columns)]
    y = np.array([1 if i == 1 else -1 for i in y])
    return X, y


X, y = getX_Y(data)


def run_algo(X, y, epochs_):
    w = np.zeros((X.shape[1], 1))
    b = 0
    epochs = 0
    no_misclassified = False;
    while not no_misclassified and epochs < epochs_:
        misclassified_count = 0
        for i in range(X.shape[0]):
            x1 = X[i,]
            y1 = y[i]
            val = y1 * (np.dot(w.T, x1.T) + b)
            if val <= 0:
                x1 = x1.reshape(x1.shape[0], 1)
                y1 = y1.reshape(1, 1)
                w += np.dot(x1, y1).reshape(x1.shape[0], 1)
                b += y1
                misclassified_count += 1
        if misclassified_count == 0:
            no_misclassified = True
        else:
            no_misclassified = False
        epochs += 1
    print("Epochs taken = {}".format(epochs))
    return w, b


if erm_normal:
    w, b = run_algo(X, y, 1000)
    print("w={}".format(w))


def fx_erm(data, X, y, w):
    w = np.insert(w, 0, 0)
    if not erm_normal:
        w = w.reshape(len(data.columns) + 1, 1)
    else:
        w = w.reshape(len(data.columns), 1)
    err_count = 0
    for i in range(len(X)):
        c_y = y[i]
        c_r = X[i]
        c_r = np.insert(c_r, 0, 1)
        if not erm_normal:
            c_r = c_r.reshape(1, len(data.columns) + 1)
        else:
            c_r = c_r.reshape(1, len(data.columns))
        if ((np.dot(c_r, w)) * c_y) <= 0:
            err_count += 1
    return err_count / len(X)


if erm_normal:
    print("ERM for data1 = {}".format(fx_erm(data, X, y, w)))


def splitIntoKBuckets(data, num_buckets):
    b_list = []
    ele = int(data.shape[0] / num_buckets)
    indx = list(range(0, data.shape[0]))

    for i in range(num_buckets):
        cnt = 0
        curr = []
        while cnt < ele:
            index = random.randint(0, data.shape[0] - 1)
            if index in indx:
                indx.remove(index)
                curr.append(data.loc[index].to_list())
                cnt += 1
        b_list.append(curr)

    if len(indx) > 0:
        b = 0
        for index in indx:
            b_list[b].append(data.loc[index].to_list())
            b += 1
            if b == num_buckets:
                b = 0

    return b_list


def doCrossValidation(b_list, data):
    for i in range(len(b_list)):
        bkts = []
        for k in range(len(b_list)):
            if (k != i):
                bkts += b_list[k]
        cols = list(data.columns)
        d = pd.DataFrame(bkts, columns=cols)
        X = d[cols].to_numpy()
        y = d[data.columns[len(data.columns)-1]].to_numpy()
        y = np.array([1 if i == 1 else -1 for i in y])
        w, b = run_algo(X, y, 1000)
        print("w={}".format(w))

        X = d[cols].to_numpy()
        y = d[data.columns[len(data.columns)-1]].to_numpy()
        y = np.array([1 if i == 1 else -1 for i in y])
        err = fx_erm(data, X, y, w)
        print("ERM = {}".format(err))
        err_list.append(err)
        print("\n")


if not erm_normal:
    buckets = splitIntoKBuckets(data, 10)
    err_list = []
    doCrossValidation(buckets, data)
    print("mean_err={}".format(np.mean(err_list)))




